UseCaseScribe
=============
This script aims to simplify the input of use case models in Modelio. The import operation consists in transforming a text written in a "Simple Use Case Notation" (SUCN) into use case elements (actors, use cases, notes, etc.). On the other way around the export operation consists in generating a SUCN text from an existing model.

Import and export operations
----------------------------
During the import operation if an element with the same name (or the same "uuid", see below) already exists, it is not created again. Its attributes or nested elements are modified instead. The import operation actually realizes a "merge" operation so the script can be used to modify/extend an existing model but but *NOT* to delete elements. Elements are *NEVER* deleted with this script. Deletions should be realized manually through the regular interface if this is the intention. One possibility is therefore to erase all elements and re-import a SUCN text if this is intented. 

The export operation generates a file in the textual notation. During the export operation "uuid" can optionally be added to the elements. These "uuid" are unique identifiers generated by modelio when an element is created. They never change. This allows elements to be moved, renamed, etc. while keeping the same uuid. If an uuid is found during the import operation (that follow an export) then the element is identified by this uuid instead of just its name. Using uuid allows to rename model elements in a sequence export - import.     

SUCN Notation
-------------
The syntax of the SUCN notation is based on simple line commands that are nested. Each line is therefore interpreted in a given context. See the examples below for concrete illustrations of the syntax. 

The general conventions are the following ones:
* Blank lines are ignored.
* Nesting is done via two spaces.
* Separator lines are ignored. These are lines containing only "*" or "=" or "-" and spaces. 
* Lines starting with "--" are comments and are ignored as well.
* If a line is terminated with "..." and then a uuid, then this is the uuid associated with the current element.
* If a name of an element appears for the first time in the text and it does not exist in the model, then the element is created. Otherwise the element is modified. If an uuid is indicated for an element, then the search is based on this uuid instead of its name.

The notation is based on nesting of simple line commands.   
* At the *top-level*:  
  * **NameA** : Create/modify an actor.
  * **NameA \< NameB** : Create/modify an actor NameA inheriting from an actor NameB. Actors are created or reused.
  * **NameA1,NameA2...NameAn - NameCU** : Create/modify a use case and associate it with the corresponding actors. Actors are created or reused. Association between actors and use cases are merged with previous ones if already existing.
* In the context of *use cases*:
  * **NameC** : Create/modify a collaboration named NameC
  * **t-> NameC** : Create a tracability (hence "t->") dependency towards the model element NameC if it exist. The element is first search in the "analyst project", and then in the "uml project".If this model element does not exist or various element with the same name exists, then a warning is issued but the process is not stopped.
* *In the context of actors, use cases or collaborations*:
  * **#s SomeText** : Create/modify the "summary" note (it is assumed that there at most one)
  * **#d" SomeText** : Create/modify the "description" note (it is assumed that there at most one)
  * **#  SomeText** : Append a text to the previous note. Note that a space should follow the "#" character.

SUCN Examples
--------------
Here is an example of SUCN text that can be used to create a blank model:
    
    Actor5
    Actor1
      #s This is the "summary" note associated with Actor1.
      #d And now a "description" note. Actors does not have
      #  to be declared unless notes have to be attached with them
      #  or they have inheritance relationships. Otherwise
      #  they are declared "online" when found
    Actor8  
    Actor4
      #s
    Actor1,Actor2 - UseCase2
    Actor6 - UseCase3
    Actor6 - UseCase4
    
    Actor2,Actor1 - UseCase5    
     
    Actor1 - UseCase1
      #s This is the "summary" of UseCase1 because "s" stands for summary.
      #d This is the "description" note attached to UseCase1.
      #  This note has various lines as each line is
      #  appended with the previous note if it start with "# " (note the space).
      #d This is another description starting here as the note type is given ("d" here).
      t-> AnNamedElementOfWhateverType
      Collaboration11
        #s This is the "summary" of the Collaboration11
        
      Collaboration12
        #s This is the "summary" of Collaboration12
        #d This is the "description" 
        #  and it continues on
        #  multiple lines.
      Collaboration13
      

Usage
-----
UseCaseScribe provides two import commands and one export command. The two import commands operates on a "selected" package (the selection refering here to modelio selection). The selected package will be the place where new elements are going to be created. Existing elements will stay in their place (see the note below). 

The three commands are the following:
* "Import use cases from file": this command must be run on a selected package and a file name in the SUCN notation must be specified.
* "Import use cases": this command is similar but a input window is open where SUCN notation can be input. Pressing a button OK allows to create use case elements.
* "Export use cases": this command generate a file for all actors, use cases and collaborations that are (recursively) in the selected package or if no package is selected that are in the UML project.  

IMPORTANT NOTE: It is assumed that actors and use cases names are global. So if existing actors or use cases have already the same names as the ones found in the model (or the same uuid if any) during an import, then these entities will be modified in the place where they are. This avoid package qualification which could be quite cumbersome in practice. It is still possible to create sophisticated structures by to first importing use cases and actors in a blank model, to create various packages and move elements in it. When the elements will be imported again, they will stay in the same package, except newly created elements that will go into the "selected" package.
